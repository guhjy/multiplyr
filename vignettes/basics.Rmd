---
title: "Multiplyr basics"
author: "Jim Blundell"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Multiplyr basics}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, echo = FALSE, message = FALSE}
library(multiplyr)
knitr::opts_chunk$set(
  comment = NA,
  error   = FALSE,
  tidy    = FALSE)
```

The multiplyr package is intended to provide simple and transparent
parallel processing functionality through an interface similar to
one already familiar to many R users (dplyr):

```r
# Construct a new data frame
dat <- Multiplyr (x=1:100, G=rep(c("A", "B", "C", "D"), length.out=100))

# Group data by G
dat %>% group_by (G)

# Summarise length(x) in each group and store in N
dat %>% summarise (N = length(x))
```

To those unfamiliar with dplyr: this package makes heavy use of the %>%
operator, which allows several operations to be chained together.
dat %>% ... results in ... being applied to the data frame called dat. 

## Multiplyr is a reference class

There is one surprising thing missing from the above code, which is the
complete absence of an assignment operator, <-, when group_by and
summarise have been used. Since these data frames represent shared memory,
things like group_by modify it in place so assigning it back to the same
object has no meaning. Attempting to assign the result of these to a different
variable may have slightly unexpected behaviour. In the current version of this
package only one data frame per cluster is supported.

## Basic operations
### Manipulating columns
#### Create new columns with define

The first thing to note with creating new columns with a Multiplyr data frame
is that the size of the underlying matrix is fixed at creation. This means
that to create new columns you need to estimate in advance how many extra
columns you might need. To allocate space for more columns on creation,
use the alloc=N parameter of Multiplyr, where N is the number of extra columns
to create. New columns are created with define, simply specifying their names
and separating with commas. 

```r
# Create new data frame with space for 3 new columns
dat <- Multiplyr (x=1:100, alloc=3)

# Create 2 new columns named y and z
dat %>% define (y, z)

# Do things with new columns
dat %>% mutate (y=x*2, z=sqrt(x))
```

The above only works for numeric columns; in order to do the same for factors
or character data, you need to specify an existing template column with the
format of newcolumn=template:

```r
# Create new Multiplyr frame with two columns (A and P) with space for 3 more
dat <- Multiplyr (A=rep(c("A", "B", "C", "D"), each=25), 
                  P=rep(c("p", "q"), each=50), 
                  alloc=3)

# Create new columns named newA and newP
dat %>% define (newA=A, newP=P)

# Set their values
dat %>% mutate (newA="A", newP="p")
```

#### Rename columns with rename
Renaming columns is easily achieved by specifying a list of newname=oldname
pairs to rename:

```r
# Create a new Multiplyr frame with variables named x, y and z
dat <- Multiplyr (x=1:100, y=100:1, z=rnorm(100))

# Rename to p, q and r
dat %>% rename (p=x, q=y, r=z)
```

#### Drop existing columns with undefine or select
There are two potential ways to drop columns from a data frame: specifying
which columns to drop (undefine), or specifying which columns to keep (select):

```r
# Create Multiplyr data frame with columns named x, y, z and misc
dat <- Multiplyr (x=1:100, y=100:1, z=rnorm(100), misc=rep(1, 100))

# Drop column named misc
dat %>% undefine (misc)

# Keep only the x and y columns
dat %>% select (x, y)
```

### Manipulating rows
filter
distinct
slice

### Manipulating data
mutate
transmute
summarise, reduce
within_node
within_group

### Grouping
group_by
group_sizes
ungroup, regroup

### Partitioning
partition_even
partition_group

## No strings attached
Data within a Multiplyr data frame is internally represented numerically,
regardless of whether it's actually numeric or not. At first this may seem
like a limitation, but can potentially make data manipulation very, very
fast. When data in a Multiplyr data frame is updated, e.g. setting a
value to "A", this results in "A" being looked up for that column's
factor levels and then assigned to the underlying numeric matrix.

However, there are times that the actual, specific content of the column
is not relevant. One way to speed up certain operations is therefore to
put the data frame into "no strings attached" mode, which disables any of
these look-ups. For example:

```
# Construct a new data frame
dat <- Multiplyr (G=rep(c("A", "B", "C", "D"), length.out=100),
                  H=rep(c("p", "q", "r", "s"), each=25))
# Display data
dat["G"]
dat["H"]

# Switch into NSA mode
dat %>% nsa()
dat["G"]
dat["H"]

# Do some things
dat %>% mutate (G=3)

# Switch back
dat %>% nsa(FALSE)
dat["G"]
dat["H"]
```

## Speed considerations/limitations

There are some things that are particularly slow with a Multiplyr data
frame. In particular, the way in which character data is handled. Any
character data is effectively converted into a factor transparently. This means
that if there is a column of text where every cell is unique, then this is
passed on in its entirety, which is very slow.

The initial creation of a parallel data frame is slow: the reason for this is
that in the background a new local cluster is started. If you have 4 cores or
CPUs then 4 new instances of R will be started, which can take a few
seconds.

This package is not (yet!) a complete replacement for dplyr and there are
some notable things missing, most notably neat interfacing with SQL
databases. Currently only one parallel data frame per cluster is supported, so
there also are't any join operations.


