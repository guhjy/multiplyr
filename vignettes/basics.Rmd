---
title: "Multiplyr basics"
author: "Jim Blundell"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Multiplyr basics}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, echo = FALSE, message = FALSE}
library(multiplyr)
knitr::opts_chunk$set(
  comment = NA,
  error   = FALSE,
  tidy    = FALSE)
```

The multiplyr package is intended to provide simple and transparent
parallel processing functionality through an interface similar to
one already familiar to many R users (dplyr):

```r
# Construct a new data frame
dat <- Multiplyr (x=1:100, G=rep(c("A", "B", "C", "D"), length.out=100))

# Group data by G
dat %>% group_by (G)

# Summarise length(x) in each group and store in N
dat %>% summarise (N = length(x))
```

To those unfamiliar with dplyr: this package makes heavy use of the %>%
operator, which allows several operations to be chained together.
dat %>% ... results in ... being applied to the data frame called dat. 

## Quirks
### Multiplyr is a reference class
There is one surprising thing missing from the example code here, which is the
almost complete absence of <-, the assignment operator. Since these data frames
represent shared memory, things like group_by modify it in place so assigning 
it back to the same object has no meaning. Attempting to assign the result of 
these to a different variable may have slightly unexpected behaviour. In the 
current version of this package only one data frame per cluster is supported.

### Data order is not maintained
The internal representation of the data is a matrix and the way that the
matrix is divided up amongst nodes is to give each node a contiguous block of
that matrix (or several blocks in the case of grouped data). The side effect
of this is that data must be sorted in a particular way.

### Text is not actually text
From the outside, Multiplyr data frames will appear to work like standard R
data frames. However, the way text is stored internally is to convert them to 
factors, which is effectively:
- Sort the data alphabetically
- Find all the unique values and give them an ID number
- Replace the data with that ID number
- Store a lookup table mapping ID number to the actual text

This has one major advantage in that numeric data is easier and faster to
manipulate and pass around. The major disadvantage, however, is that if a
column has a lot of unique values of text then there's a large overhead in
converting and passing to the cluster what these unique values are.

I wouldn't recommend using this package for data where you have columns 
with lots of unique values of text unless that text represents some sort of 
grouping.

## Basic operations
### Manipulating columns
#### Create new columns with define

The first thing to note with creating new columns with a Multiplyr data frame
is that the size of the underlying matrix is fixed at creation. This means
that to create new columns you need to estimate in advance how many extra
columns you might need. To allocate space for more columns on creation,
use the alloc=N parameter of Multiplyr, where N is the number of extra columns
to create. New columns are created with define, simply specifying their names
and separating with commas. 

```r
# Create new data frame with space for 3 new columns
dat <- Multiplyr (x=1:100, alloc=3)

# Create 2 new columns named y and z
# Note that this define is actually not needed as mutate will define implicitly
dat %>% define (y, z)

# Do things with new columns
dat %>% mutate (y=x*2, z=sqrt(x))
```

As you will see in later sections, the above define operation was not actually
technically necessary as mutate will create new columns if they do not already 
exist.

One time where define is not superfluous is when creating columns that will
store factors or text. For this, along with the name of the new column, you
need to specify a template to copy in the form of newcolumn=template:

```r
# Create new Multiplyr frame with two columns (A and P) with space for 3 more
dat <- Multiplyr (A=rep(c("A", "B", "C", "D"), each=25), 
                  P=rep(c("p", "q"), each=50), 
                  alloc=3)

# Create new columns named newA and newP
dat %>% define (newA=A, newP=P)

# Set their values
dat %>% mutate (newA="A", newP="p")
```

#### Rename columns with rename
Renaming columns is easily achieved by specifying a list of newname=oldname
pairs to rename:

```r
# Create a new Multiplyr frame with variables named x, y and z
dat <- Multiplyr (x=1:100, y=100:1, z=rnorm(100))

# Rename to p, q and r
dat %>% rename (p=x, q=y, r=z)
```

#### Drop existing columns with undefine or select
There are two potential ways to drop columns from a data frame: specifying
which columns to drop (undefine), or specifying which columns to keep (select):

```r
# Create Multiplyr data frame with columns named x, y, z and misc
dat <- Multiplyr (x=1:100, y=100:1, z=rnorm(100), misc=rep(1, 100))

# Drop column named misc
dat %>% undefine (misc)

# Keep only the x and y columns
dat %>% select (x, y)
```

### Grouping
#### Grouping data
One of the main strengths of the manipulations on data with multiplyr (as it
is with dplyr) is that data may be arranged in groups first, with operations
then taking place on individual groups.

Consider the experiment where 60 guinea pigs were given Vitamin C as either a
supplement or in the form of orange juice at 3 different doses We can produce
a table of summary statistics with the mean and standard deviation for each 
combination of supplement and dose as follows:

```r
# Load data on guinea pig tooth growth:
#  len    Odontoblast (tooth cell) length
#  supp   Supplement (VC = Vit C supplement, OJ = Orange Juice)
#  dose   Dose in mg (0.5, 1 or 2)
#
data (ToothGrowth)

# Convert into a Multiplyr data frame with space for 2 new columns
dat <- Multiplyr (ToothGrowth, alloc=2)

# Group data by supplement and dose
dat %>% group_by (supp, dose)

# Produce summary statistics
dat %>% summarise (len.mean = mean(len), len.sd = sd(len))
```

#### Ungrouping and regrouping
Returning a data frame back to ungrouped form is achieved simply using ungroup.
It is also possible to easily revert back to a grouped form using the same
groupings with regroup.

```r
# Load data on guinea pig tooth growth:
data (ToothGrowth)
dat <- Multiplyr (ToothGrowth)

# Group data by supplement and dose
dat %>% group_by (supp, dose)

# Ungroups data
dat %>% ungroup()

# Regroups data (implicitly by supplement and dose)
dat %>% regroup()
```

### Manipulating rows
#### Filtering based on criteria with filter
A basic operation when working with data is to select a subset of rows based
on certain criteria.

```r
# Load data on guinea pig tooth growth:
data (ToothGrowth)
dat <- Multiplyr (ToothGrowth)

# Group by supplement
dat %>% group_by (supp)

# Select only guinea pigs with a dose >= 1 mg/kg
dat %>% filter (dose >= 1)

# Produce summary
dat %>% summarise (mean.len = mean(len))
```

#### Filtering out duplicates with distinct

#### Selecting a specific subset wih slice

### Manipulating data
#### Updating values with mutate
#### Updating values and dropping other columns with transmute
#### Summarising data with summarise and reduce
#### Executing arbitrary code using within_*


### Partitioning

## No strings attached
Data within a Multiplyr data frame is internally represented numerically,
regardless of whether it's actually numeric or not. At first this may seem
like a limitation, but can potentially make data manipulation very, very
fast. When data in a Multiplyr data frame is updated, e.g. setting a
value to "A", this results in "A" being looked up for that column's
factor levels and then assigned to the underlying numeric matrix.

However, there are times that the actual, specific content of the column
is not relevant. One way to speed up certain operations is therefore to
put the data frame into "no strings attached" mode, which disables any of
these look-ups. For example:

```
# Construct a new data frame
dat <- Multiplyr (G=rep(c("A", "B", "C", "D"), length.out=100),
                  H=rep(c("p", "q", "r", "s"), each=25))
# Display data
dat["G"]
dat["H"]

# Switch into NSA mode
dat %>% nsa()
dat["G"]
dat["H"]

# Do some things
dat %>% mutate (G=3)

# Switch back
dat %>% nsa(FALSE)
dat["G"]
dat["H"]
```

## Speed considerations/limitations

There are some things that are particularly slow with a Multiplyr data
frame. In particular, the way in which character data is handled. Any
character data is effectively converted into a factor transparently. This means
that if there is a column of text where every cell is unique, then this is
passed on in its entirety, which is very slow.

The initial creation of a parallel data frame is slow: the reason for this is
that in the background a new local cluster is started. If you have 4 cores or
CPUs then 4 new instances of R will be started, which can take a few
seconds.

This package is not (yet!) a complete replacement for dplyr and there are
some notable things missing, most notably neat interfacing with SQL
databases. Currently only one parallel data frame per cluster is supported, so
there also are't any join operations.


